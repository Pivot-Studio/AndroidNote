- ## 结构
	- okhttp是一个优秀的网络请求框架，OkHttp 主要是通过 5 个拦截器和 3 个双端队列（2 个异步队列，1 个同步队列）执行工作，OkHttp 的底层发送 HTTP 请求与接受响应是通过 Socket ，同时实现了连接池。
- ## 过程
- ![](https://img-blog.csdn.net/20180228221939390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGdnX2NvbGQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
-
- ## 请求
	- ### 异步
		- 两个队列和一个线程池负责异步操作，默认执行5个并发请求，同时允许持有的最大并发异步请求数量是64.
		- 两个队列分别为
			- 待访问请求队列，里面存储准备执行的异步请求，超过默认执行并发请求的最大数量，会被添加到此队列。
			- 异步请求队列，存储正在执行的异步请求，提交通过call.enqueue实现异步操作。
	- ### 同步
		- 同步请求队列，通过call.excute实现同步操作。没有线程池。它会阻塞线程去获取数据。
- ## 拦截器
	- ### 缓存拦截器
		- OkHttp只会对get请求进行缓存，post请求是不会进行缓存，这也是有道理的，因为get请求的数据一般是比较持久的，而post一般是交互操作，没太大意义进行缓存。
		- 强制缓存，即缓存在有效期内就直接返回缓存，不进行网络请求。
		- 对比缓存，即缓存超过有效期，进行网络请求。若数据未修改，服务端返回不带body的304响应，表示客户端缓存仍有效可用；否则返回完整最新数据，客户端取网络请求的最新数据
- ## 连接池复用
	- 优点：在高并发的请求连接情况下或者同个客户端多次频繁的请求操作，无限制的创建会导致性能低下。在`timeout`空闲时间内，连接不会关闭，相同重复的request将复用原先的`connection`，减少握手的次数，大幅提高效率。
	-
	- 缺点：并非`keep-alive`的timeout设置时间越长，就越能提升性能。长久不关闭会造成过多的僵尸连接和泄露连接出现。
	- ### 复用：
		- 遍历connections缓存列表，当某个连接计数的次数小于限制的大小以及request的地址和缓存列表中此连接的地址完全匹配。则直接复用缓存列表中的connection作为request的连接。
	- ### 清理回收：
		- 会有专门的线程中不停调用`Cleanup` 清理的动作并立即返回下次清理的间隔时间。
		- 引用计数器`List<Reference<StreamAllocation>>`会记录所有连接的活跃程度。`StreamAllocation`被高层反复执行`aquire`与`release`。这两个函数在执行过程中其实是在一直在改变`Connection`的的 `List<WeakReference<StreamAllocation>>`大小。
		- 当活跃度被识别为0,并且需要进行清理的时候，就会被清除掉。
- ## 设计模式
	- [[构造者模式]]（OkhttpClient,Request 等各种对象的创建）
		- 优点：我们不再关注OkHttpClient/Request的构建细节，不用每次构建时都传入大量参数，只需要传递我们关心的参数，非常易用；
	- [[工厂模式]]  Call接口中用到了内部工厂接口
	- [[单例模式]]线程池（）
	- [[责任链模式]]（拦截器的链式调用）
	- [[策略模式]]（在 CacheInterceptor 中，在响应数据的选择中使用了策略模式，选择缓存数据还是选择网络访问。）
-