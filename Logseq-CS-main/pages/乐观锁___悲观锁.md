- ### 乐观锁
	- 乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。 因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。
	- #### 实现
		- 1.CAS，如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作。
		- 许多CAS的操作是自旋的：如果操作不成功，会一直重试，直到操作成功为止。
		- 2.版本号机制，在数据表加上数据版本号version,每线程需要修改数据时，先读取数据获取版本号，在提交更改时如果当前的version和刚刚读取到的version相同就允许进行相应操作，然后将version++
		- 3.AtomicInteger
	- #### 优点
		- 适用于线程数量少，线程任务能很快进行完成的操作，这时候用乐观锁
		- 比方说CAS基于硬件实现，不需要进入内核态，不需要像synchronized那样切换线程
	- #### 缺点
		- 存在ABA问题，版本号机制可以解决
		- 很多CAS操作是带自旋的，如果不成功就会一直操作一直操作，线程一直在运行而不是像synchronized 那样会陷入阻塞，cpu开销较大
### 悲观锁
	- 悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据，例如：Synchronized，ReentrantLock
	- #### 优点
		- 适用于线程数量多，线程任务不是很短的任务
	- #### 缺点
		- 使用synchronized同步锁进行线程阻塞和唤醒需要用户态内核态间的切换操作，导致额外浪费消耗cpu资源