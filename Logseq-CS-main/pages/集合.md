- ## [[ArrayList]]
	- 底层是数组
	- ### 初始化
		- jdk1.8之前默认长度为10，
		- jdk1.8之后先创建的是空数组，然后添加第一个元素后才会将长度变为10，扩容时是位运算
	- ### 添加元素
		- ArrayList每次当长度不足时，进行长度扩容，将原先长度二进制右移一位的值与原先长度相加，就是原先长度的1.5倍,扩容后会通过Arrays.copyof()进行拷贝
- ## [[LinkedList]]
	- 底层是双向链表
- ## [[HashSet]]
	- ### 添加元素
		- HashSet中的元素都是存放在Hashmap中的key中，value值统一为一个固定final对象，hashset的add实际上调用的就是HashMap的put
- ## [[HashMap]]
	- ### 初始化
		- 先创建的是空数组，然后put添加第一个元素后才会将长度变为16
	- ### 添加元素
		- 通过key计算得到hash值查找到对应位置
			- 将key通过哈希函数计算得到的hash值无符号右移16位于原先哈希值求异或得到真正的哈希值（相当于高八位和低八位），然后将hash值与数组的长度length-1进行求与运算，其范围刚好在length之内，这个数作为value的存储位置，
		- 如果对应位置为空则直接加入
		- 如果对应存储位置存在链表再通过key进行查询添加在末尾，之后根据其长度决定是否将链表替换成红黑树
		- 或者对应存储位置存在红黑树就按照红黑树的规则进行添加。
- ## ConcurrentHashMap
	- CAS+synchronized保证线程安全+数组+链表/红黑二叉树。synchronized锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发。
- ## LinkedHashMap
	- 是在hashmap的基础上维护了一个双向链表
	- 构造的时候将其accessOrder设为true,无论是get还是put找到这个结点在链表中的位置，并移动到链表结尾。这样链表的头结点就是链表最久没有访问过的结点每次get/put。
	- 构造的时候accessOrder设为false，只有put会让其处于链表尾端
	- Lru算法里面会在每次get/put的时候判断数据如果达到了maxSize,则会优先删除链表头部的数据。
- ## [[Queue]]
- ## [[Deque]]
- ## [[Stack]]
- ## [[Math]]
- ## 面试
	- ### ArrayList与LinkedList的区别
		- 底层实现：
			- ArrayList底层是数组，查找某个元素的时间复杂度是O(1)
			- LinkedList以元素列表的形式进行数据存储，每一个节点存储两个引用一个指向上一个元素，一个指向下一个元素，查找某个元素的时间复杂度是O(n)
		- 扩容：
			- arraylist每次当长度不足时，进行长度扩容，将原先长度二进制右移一位的值与原先长度相加，就是原先长度的1.5倍,扩容后会通过Arrays.copyof()进行拷贝
			- linkedlist则由于是链表，不存在扩容
		- 作用：
			- ArrayList搜索快，LinkedList增删快
	- ### ArrayList线程安全方法？
		- 使用Vector
		- Collections.synchronizedList(new ArrayList<>())
	- ### ArrayList适合做队列吗？
		- 不适合，因为需要频繁的数组搬迁
	- ### 复制一个ArrayList的方法？
		- clone()
	- ### HashMap和Hashtable的区别
		- 底层实现：
			- HashTable不允许key,value值为空，HashMap允许
		- 扩容：
			- HashTable默认长度为11，数组元素超过 数组容量 * 0.75，则容量翻倍并+1，HashMap默认长度为16，数组元素超过 数组容量 * 0.75取整，则容量翻倍
			- 计算hash的方法不同，HashTable直接调用Hashcode方法，HashMap，将hash值无符号右移16位于原先哈希值求异或，这样是为了更好的散列
		- 作用：
			- HashTable是线程安全的其中的重要方法都有synchronized修饰，HashMap是线程不安全的
	- ### HashMap为什么达到大小的0.75倍时进行扩容
		- 根据泊松分布，当取0.75时空间和时间效率最佳
	- ### HashMap为什么使用红黑树？
		- 红黑树需要进行左旋，右旋，变色这些操作来保持平衡
		- 当存储元素较少时，链表的性能更佳
		- 当数量足够多时红黑树查询效率会提高
	- ### HashMap有哪些让他线程安全的方法？
		- 使用hashtable
		- 过Collections.synchronizedMap()返回一个新的Map
		- 使用ConcurrentHashMap，它使用分段锁来保证线程安全，正常比如说访问hashtable，是将hashtable的所有元素锁起来，conCurrentHashMap则是将底层数组分为一段一段的部分挨个进行锁
	- ### HashMap内存泄漏原因？
		- 比方说在hashmap中重复存储自定义类，如果自定义类没有重写hashcode和equals方法就会导致本身重复的元素被反复添加，最终OOM