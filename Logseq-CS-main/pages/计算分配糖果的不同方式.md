- ## 题目
	- 现有 n 颗 不同 糖果（分别标记为 1 到 n ）和 k 个相同的手袋。请把糖果分配到各个手袋中并保证每个手袋里至少有一颗糖果。
	- 不考虑手袋和糖果的摆放顺序，会有多种不同的分配方式。如果某种分配方式中其中一个手袋里的糖果与另一种分配方式中所有手袋里的糖果都不相同，则认为这两种分配方式不同。
	- 例如，(1), (2,3) 与(2), (1,3)的分配方式是不同的，因为第一种分配方式中手袋(2,3)里的糖果2和3，在第二种分配方式中被分配到了手袋(2)和(1,3) 中。
	- 已知整数 n 和 k, 请返回分配糖果的不同方式。返回的答案如果数值太大，请取109 + 7的模，并返回。
- ## Code
	- 方法一：动态规划
	- dp[i][j]代表i个糖果放在j个袋子中
	- 状态方程分析：dp[i][j]=(dp[i-1][j-1]+j*dp[i-1][j])
	- 两种情况：第j个袋子只有第i个糖果（dp[i-1][j-1]），第j个袋子不是只有第i个糖果(说明初始条件是第i个糖果就未被放入，即dp[i-1][j],第i个糖果可能被放在任意一个袋子所以再乘以j)
	- ```java
	  class Solution {
	      public int waysToDistribute(int n, int k) {
	          long MOD=(long)(Math.pow(10,9)+7);
	          long[][] dp=new long[n+1][k+1];
	          dp[0][0]=1;
	          for(int i=1;i<=n;i++){
	              for(int j=1;j<=k;j++){
	                  dp[i][j]=(dp[i-1][j-1]+j*dp[i-1][j])%MOD;
	              }
	          }
	          return (int)dp[n][k];
	      }
	  }
	  ```