- ## 线程状态
	- 新建态 ：[[Thread类]]，[[Runnable接口]]，[[Callable接口]]
	- 新建态-->就绪态 ：调用Thread.start()方法
	-
	- [[就绪态]]-->运行态 ：等待到CPU执行权
	-
	- [[运行态]]-->就绪态 ：线程礼让：[[Thread.yield()方法]]
	- 运行态-->阻塞态 ：[[Thread.sleep()方法]]，[[Thread.join()方法]]，[[锁对象.wait()方法]],I/O操作（例如需要输入输出）
	- 运行态-->死亡态 ：Thread.stop()方法，线程自然运行结束
	-
	- [[阻塞态]]—>运行态
- ## 线程同步
	- [[volatile]]
	- [[锁]]
		- [[Synchronized]]
		- [[ReentrantLock]]
		- [[锁对象.wait()方法]]
	- [[ThreadLocal]]
- ## 守护线程
	- 实现 ：通过Thread.setDemon(false),来将用户线程变成守护线程，
	- 当所有用户线程结束时，守护线程也会自己销毁及时其有任务在运行，除了这一个特点其他和用户线程相同，比如：GC垃圾回收线程
- ## 协程
	- 用户态的轻量级线程
	- 协程切换时，将寄存器上下文和栈保存到其他地方，在切回来后直接恢复，基本没有内核切换的开销，极大提高了线程切换的效率
	- 同一时间只有一个协程拥有使用权，相对于单线程的能力
- ## NIO
	- NIO主要用于开发网络服务器和客户端，它能够支持大量的并发连接，使得单个线程可以管理多个连接，而不像传统的阻塞I/O，每个连接都需要一个单独的线程来管理。因此，使用NIO可以有效地提高服务器的并发处理能力和响应速度。
- ## 断点续传
	- 将一个文件分成若干个部分，每个部分单独下载，下载完成后将这些部分合并成一个完整的文件。
	- 在传输中断的位置保存传输的状态信息，当再次传输时，只需要从上一次中断的位置开始传输，可以大大提高传输的效率。
	-
- ## [[线程池]]
-
- ## 面试
	- ### 为什么使用多线程？
		- 因为单线程处理能力低。打个比方，一个人去搬砖与几个人去搬砖，一个人只能同时搬一车，但是几个人可以同时一起搬多个车。
	- ### java为什么需要线程同步？
		- 当多个线程访问同一数据并作出修改时，为保证其逻辑的有序性所以需要实现线程同步，多个线程按照一定次序进行访问。
	- ### 线程安全的三大特性？
		- 原子性：
			- 一个操作要么全部执行要么不执行，执行时无法被打断
		- 可见性：
			- 当多个线程访问同一变量时，一个线程修改时，其他线程可以看见
		- 有序性：
			- 代码执行的顺序和java文件中代码的顺序相同，JVM有些时候为了提高程序的运行效率，可能会让部分指令重写排序扰乱了有序性（如果a步骤对b步骤有依赖性就不会发生指令重排）
	- ### sleep和wait的区别？
		- 使用位置：
			- wait()只能用于同步必须包裹在synchronized下面，sleep()什么情况下的线程中都行。
		- 锁对象：
			- 由于很多时候wait是通过锁进行调用的，锁甚至可以是object类型的，但是sleep只能调用Thread变量的。
		- 唤醒：
			- wait()使用后释放当前线程的锁，随机访问其他同步代码，其线程进入阻塞状态，后不进行notify()唤醒其线程就永远不会执行了，sleep()超过规定时间后会继续执行。
	- ### 为什么wait,notify,notifyall这些方法不在thread类里面运行？
		- java提供的是对象级的锁不是线程级的锁
	- ### synchronized修饰静态方法和非静态方法有什么区别？为什么？
		- 修饰静态方法获取的是类锁（可以同时访问其内部其他非静态方法），修饰非静态方法实际上是对调用该方法的对象加锁（可以同时访问其内部其他非静态方法），可以访问其内部的
		- 类的静态成员(变量和方法)在类加载的时候就会分配内存，属于类本身，非静态成员（变量和方法）只有在类的对象产生（创建类的实例）时才会分配内存，属于类的对象。
	- ### 同一个类里面两个synchronized方法，两个线程同时访问?
		- 修饰非静态方法实际上是对调用该方法的对象加锁
	- ### synchronized代码块的锁一般用啥？
		- 一般用.class文件，因为一个类只对应一个.class文件，或者多个线程传入的相同的修改变量，也是唯一的，以及用final修饰的变量
	- ### ReentrantLock和synchronized的区别？
		- 原理：
			- ReentrantLock底层依赖的是AQS，synchronized底层依赖的是monitor监视器。
		- 范围：
			- ReentrantLock锁的范围有局限性，仅适用于代码块范围，而synchronized可以锁住代码块、对象实例、方法，类。
		- 唤醒：
			- ReentrantLock可以配合condition，实现分组唤醒需要的线程；synchronized要么随机唤醒一个，要么唤醒全部线程。
		- 等待中断：
			- ReentrantLock可以让等待的线程中断，一定程度上可以避免死锁，synchronized不能，等待的线程只能一直等下去。
	- ### volatile与synchronized区别？
		- 原理：
			- volatile是基于内存屏障实现，不会导致死锁，synthronized是基于锁机制，synthronized的性能弱一点，
		- 范围：
			- volatile只能用于变量，而synchronized可以用于变量，方法，类
		- 高并发特性：
			- volatile只能保证修改的可见性但是不能保证原子性，synchronized两者都可以保证
	- ### 为什么使用线程池？
		- 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
		- 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
		- 提高线程的可管理性。线程池可以独立负责创建，维护和分配，当执行大量任务线程池会尽可能的分配空闲的线程去执行任务，拒绝策略
	- ### 你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？
		- 线程安全问题：当多个线程访问同一个共享资源时，可能会出现数据不一致或其他意外结果。解决该问题的方法包括使用锁（如 synchronized 关键字或 Lock 接口），使用线程安全的容器，或使用并发工具类（如 AtomicInteger）等。
		- 死锁：当两个或多个线程相互等待对方释放资源时，就会发生死锁。解决该问题的方法包括避免嵌套锁、按照固定的顺序获取锁、使用超时机制或者死锁检测等。
		- 活锁：当多个线程都在不断地修改共享资源，但却无法继续执行时，就会发生活锁。解决该问题的方法包括引入随机性、使用线程睡眠、更改算法等。
		- 饥饿：当某个线程无法获得所需的资源而一直处于等待状态时，就会发生饥饿。解决该问题的方法包括使用公平锁、避免线程优先级过高等。
	- ### 为什么不推荐使用Executors创建线程池？
		- 因为虽然返回的是ThreadPoolExecutor对象，但是好多参数设置是预设的，容易导致OOM等问题。
	-