- ## 垃圾选择机制
	- ### 针对区域
		- 垃圾回收主要针对的区域是堆内存、方法区(JDK1.8以前)，JDK1.8方法区取消，改为元数据区。
		- 程序计数器、虚拟机栈、本地方法栈，这几块内存空间，GC是不考虑的，因为它们与线程共生死，线程结束，这里的内存也将自动被释放。
	- ### 引用计数法
		- 给对象添加引用计数器，每当有一个地方引用了，计数就加1，每当引用失效了，计数就减一，任何时候引用计数为0时，对象就是不可再被使用的。
	- ### 可达性分析算法
		- 现代虚拟机基本都是采用可达性分析算法来判断对象是否存活，
		- #### 原理
			- 以一系列叫做[[GC Root]]  的对象为起点出发， 将对象串成的一条引用链，直到所有对象都遍历完毕,如果相关对象不在任意一个以 GC Root 为起点的引用链中，则这些对象会被判断为垃圾对象,会被 GC 回收。
- ## GC垃圾回收清除机制
	- ### 标记-清除法
		- 该回收机制即为表面意思，先标记，然后把标记的内存回收，即释放。
		- 该回收算法容易产生很多内存碎片，导致大的对象没有足够的连续内存，会触发GC。
	- ### 标记-整理法
		- 标记整理法，与标记清除法一样，在标记清除完之后，会将内存进行归整，使内存碎片能够连续，避免了标记清除回收算法的弊端，但是大范围的整理任然消耗性能
	- ### 复制算法
		- 将内存平均分成A、B两块。
		- 新生对象被分配到A块中未使用的内存当中。当A块的内存用完了，清理A块所有对象， 把A块的存活对象对象复制到B块。
		- 新生对象被分配的B块中未使用的内存当中。当B块的内存用完了， 清理B块所有对象。把B块的存活对象对象复制到A块。
		- 堆所采用的回收算法就是复制算法（[[堆的垃圾回收机制]]）
- ## finalize()方法
	- ### 作用
		- 在对象经过垃圾识别算法后，不在以GCroot为起点的引用链上后，会判断对象是否重写了finalize方法，如果重写了就调用，主要用于进行垃圾回收前的工作
	- ### 缺点
		- finalize()只会被调用一次，及时在finalize方法中将对象恢复为存活状态，之后再次被判定为可回收对象后就不会再运行了
		- finalize()的优先级较低，有一个自己的相关线程在处理器任务，不能及时的将其内部任务完成