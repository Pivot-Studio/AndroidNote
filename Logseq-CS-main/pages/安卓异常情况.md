- ## 未响应(Android not response)
	- 程序没有响应
	- 5秒内无法响应屏幕触摸事件或键盘输入事件
	- 服务，广播，内容提供器前台或后台任务未在指定时间内完成（不包括activity，onCreate中死循环不会导致ANR）
- ## 内存泄漏(Memory leak)
	- ### 静态集合类引起的内存泄露
		- 像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放
	- ### 使用单例模型导致的内存泄漏
		- 单例的静态特性导致其生命周期同应用一样长
		- 比如在单例模型中存放context，如何存放的时Activity的context,他的Context本应该是随着Activity的销毁而销毁的，但是引用始终存在，所以就不能被GC回收掉，导致内存泄漏
		- #### 解决方法
			- 使用弱引用保存context,或者用getApplicationContext()替代Context
	- ### 使用非静态内部类导致的内存泄漏
		- 当活动生命周期结束时，但是非静态内部类被异步线程(比方说handler)使用，此时由于其内部任然保持着对外层类的引用(在编译期就决定的，可以在.class文件中看出)，只要引用任然保持，就无法被正常销毁，导致内存泄漏
		- #### 解决方法
			- 修改为静态内部类,静态内部类不在持有对外部类的引用,以及在静态内部类确实想要持有activity得引用的话就将其放在弱应用里面
	- ### 使用匿名内部类导致的内存泄漏
		- 当活动生命周期结束时，释放对象的时候没有删除自己以匿名内部类设置的监听器，这个匿名内部类持有外部类Activity的引用导致内存泄漏。
		- #### 解决方法
			- 生命周期结束时删除监听器（Android 系统在 Activity 销毁时会自动将该 Activity 中所有的 View 对象的监听器置为 null）
- ## 内存溢出(Out of memory)
	- ### 减小对象的内存占用
		- 使用更加轻量的数据结构，例如，我们可以考虑使用ArrayMap/SparseArray而不是HashMap等传统数据结构
		- 压缩图片，减小Bitmap对象的内存占用
	- ### 内存对象的重复利用
		- 代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用StringBuilder来替代频繁的“+”
		- Bitmap对象的复用图片，使用图片缓存技术，及时回收bitmap内存
		- 注意在ListView/GridView等出现大量重复子组件的视图里对ConvertView的复用
- ## 闪退(Crash)
	- 遇到系统无法处理的异常或错误