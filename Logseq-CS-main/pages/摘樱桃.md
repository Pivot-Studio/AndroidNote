- ## 题目
	- 一个N x N的网格(grid) 代表了一块樱桃地，每个格子由以下三种数字的一种来表示：
	- 0 表示这个格子是空的，所以你可以穿过它。
	  1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。
	  -1 表示这个格子里有荆棘，挡着你的路。
	  你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃：
	- 从位置 (0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）；
	  当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；
	  当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）；
	  如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。
- ## Code
	- 方法一：动态规划
	- 将来回问题转换成两个人从同一起点出发问题
	- 但从分析的角度出发，两者是否同时出发均可，只要保证同一位置的樱桃不被重复获取即可
	- 所以这里选择同时出发，同时出发存在规则，x1+y1=x2+y2=k，这样两者到达相同位置时也只能同时
	- 由于存在关系：x1+y1=x2+y2=k，用k,x1,x2来转换成两个同时出发人的坐标
	- ### 循环遍历条件
	- 1<=k<=2n-2   0<=x1<=n-1   0<=x2<=n-1
	- y1=k-x1，当k-x1>n-1时，显然y1超出范围，当k-x1小于0时，也超出范围
	- 当k<n-1时，x1取值从0开始到，n-1结束
	- 当k>=n-1时，x1取值从k-(n-1)开始，到k结束
	- x1,x2都需要保证此规则进行遍历，就可以访问完所有坐标
	- ### dp思路
	- dp[k][x1][x2]代表对应坐标两者所积累的樱桃数
	- 两个人到达当前点的情况一共四种
	- 下下，右右，下右，右下
	- 下的话，x不变，y减一，右的话，y不变，x减一
	- 当前路越界或者为障碍时当前位置无法接收到其采的樱桃，此情况一律设施为-1，从原点发展来的通路一定大于等于0
	- ```java
	  class Solution {
	      public int cherryPickup(int[][] grid) {
	          int n = grid.length;
	          int[][][] dp= new int[n*2+1][n+1][n+1];
	          for (int i=0;i<=n*2;++i){
	              for (int j=0;j<=n;++j){
	                      Arrays.fill(dp[i][j],-1);
	              }
	          }
	          dp[2][1][1] = grid[0][0];
	          for (int k=3;k<=n*2;++k) {
	              for (int x1 = Math.max(k-n, 1); x1 <=Math.min(k-1,n); ++x1) {
	                  for (int x2 = Math.max(k-n, 1); x2 <=Math.min(k-1,n); ++x2) {
	                      int y1 = k-x1;
	                      int y2 = k-x2;
	                      if (grid[x1-1][y1-1]==-1||grid[x2-1][y2-1]==-1){
	                          dp[k][x1][x2]=-1;
	                          continue;
	                      }
	                      int res=-1;
	                      res = Math.max(res,dp[k-1][x1][x2]); // 都往右
	                      res = Math.max(res,dp[k-1][x1-1][x2]); // 往下，往右
	                      res = Math.max(res,dp[k-1][x1][x2-1]); //往右，往下
	                      res = Math.max(res,dp[k-1][x1-1][x2-1]); // 都往下
	                      if(res!=-1){
	                          res += grid[x1-1][y1-1];
	                          if (x2!= x1) { // 避免重复摘同一个樱桃
	                              res+=grid[x2-1][y2-1];
	                          }
	                      }
	                      dp[k][x1][x2]=res;
	                  }
	              }
	          }
	          return Math.max(dp[n*2][n][n], 0);
	      }
	  }
	  
	  ```